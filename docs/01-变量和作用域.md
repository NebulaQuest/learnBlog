# 作用域链和作用域

## 作用域
### 引擎
- 负责整个javaScript 的**编译**和**执行**过程

### 编译器

- 负责语法分析和代码生成

### 作用域

- 负责收集所有声明的标识组成的一系列查询，并**执行一套规则**，来确定代码对这些标识的**访问权限**

### var a = 2

- 在编译执行的时候分为两步
- 编译器：遇到 var a 询问**编译器** 在这个作用域是否有同样的变量 如果编译器返回是,那么就会忽略这个变量；如果返回否那么就会声明一个新变量，并命名为a
```aiignore
    if(编译器返回为是){
        retrun 
    }else{
        编译器生成创建变量的代码
    }
```
- 引擎 ：在引擎执行代码的时候，会执行a = 2的部分，先询问作用域，在当前的作用域是否有a这个变量，如果没有找到，那么就会继续外层的作用域查找
```aiignore
    if(作用域返回是){
        执行变量赋值的操作
    }else{
        继续向上级的作用域查找
    }
```

### LHS 和 RHS

- LHS 是赋值操作。区别在于我不需要知道这个值存储的数据是什么
- RHS 是获取变量的操作。必须知道这个值存储的数据是什么

### 作用域链

#### RHS
当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用
域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，
或抵达最外层的作用域（也就是全局作用域）为止。找不到就会报异常

#### LHS

与RHS基本相同，LHS 操作。并且是var 的时候，如果查到最外层的时候依然没有找到，那么就会自动为你创建变量**（非严格模式下）**
严格模式下依然会报异常

### 作用域的错误使用

- 使用变量的时候应该将变量声明在属于该作用域的最小范围，下面这种可能会被其他的方法污染

```javascript
    var i;
    function makeData() {
    i = 10
    }
    function foo() {
        function bar(a) {
            i = 3; // 修改 for 循环所属作用域中的 i
            console.log( a + i );
        }
        for (var i=0; i<10; i++) {
            bar( i * 2 ); // 糟糕，无限循环了！
        }
    }
    foo();
```

### 立即执行函数表达式

- 这里提到立即函数表达式是因为这种写法将函数包裹在一个作用域之内，将内部的变量“隐藏”起来了，预防变量的污染
- 函数表达式和函数是两种定义，包装函数的声明以 (function... 而不仅是以 function... 开始。尽管看上去这并不是一个很显眼的细节，但实际上却是非常重要的区别。函数会被当作函数表达式而不是一个标准的函数声明来处理。

```javascript
    // 一个立即执行函数表达式
    (function foo() {
        var a = 3;
        console.log( a ); // 3
    })();
```