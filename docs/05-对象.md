## 对象

- JavaScript中很多都是由对象组成的，例如函数，例如数组
- 函数就是对象的一个子类型（从技术角度来说就是“可调用的对象”）。JavaScript 中的函
  数是“一等公民”，因为它们本质上和普通的对象一样（只是可以调用），所以可以像操作
  其他对象一样操作函数（比如当作另一个函数的参数）。
- 数组也是对象的一种类型，具备一些额外的行为。数组中内容的组织方式比一般的对象要
  稍微复杂一些。

### 内置对象
- String Number Boolean Object Function Array 都是内置对象
- 以Number来举例

声明一个Number有两种方法：
1. `const  a = 111`
2. `const  a = new Numebr(111)`

但是并不推荐使用第二种形式写法：const numObj = new Number(10);（返回 Number 对象，非原始 number 类型）
问题：原始类型（10）比对象更高效，且类型判断易出错（typeof numObj === "object"，而非"number"）。

| 维度       | 原始 number（如10）             | Number 对象（如new Number(10)）                      |
|----------|----------------------------|-------------------------------------------------|
| 本质       | 基本数据类型（纯数字值）               | 引用数据类型（包装了数字的对象）                                |
| 类型判断     | typeof 10 === "number"（正确） | typeof new Number(10) === "object"（易踩坑）         |
| 核心用法     | 直接运算、赋值（日常 99% 场景够用）       | 可调用对象方法（如numObj.toString()），但原始值会自动 “装箱” 实现同样效果 |
| 效率 & 推荐度 | 更高效，强烈推荐                   | 冗余占内存，仅特殊场景（如需绑定属性）用，日常禁用                       |\

#### “装箱”的原理

核心原理：JS 引擎自动临时装箱，原始值本身无方法，调用时会被临时包装成 Number 对象，用完即销毁。

通俗拆解（以10.toString()为例）
1. 当你写10.toString()时，JS 发现原始值要调用方法，先悄悄创建临时 Number 对象：new Number(10)；
2. 用这个临时对象调用toString()方法，得到结果；
3. 立即销毁临时对象，最终返回结果，原始值10依然是基本类型，没任何变化。
4. 
简单说：原始值是 “临时工”，需要干活（调用方法）时，JS 给它配个 “工具人”（临时对象），干完活就解雇工具人，临时工本身不变。

null 和 undefined 没有对应的构造形式，它们只有文字形式。相反，Date 只有构造，没有
文字形式。

### 数组

- 数组也是一个对象，也可以通过下标给数组添加属性值,但是这并不会改变数组的长度

```javascript
    var myArray = [ "foo", 42, "bar" ];
    myArray.baz = "baz";
    myArray.length; // 3
    myArray.baz; // "baz"
```

### 复制对象
//TODO 浅拷贝的方式有哪些，如何实现一个深拷贝

### 属性描述符

- 查看一个属性的描述，使用的是 `Object.getOwnPropertyDescriptor( myObject, "a" )` 第一个参数是对象，第二个参数是属性
- 创建一个属性并对属性描述进行修改的方式是使用 `Object.defineProperty()` 第一个参数是对象，第二个参数是属性，第三个参数是配置信息

[演示](../demos/04-对象.html)

1. Writable
   writable 决定是否可以修改属性的值。属性值的修改静默失败（silently failed）了。如果在严格模式下，这
   种方法会出错
2. Configurable
   只要属性是可配置的，就可以使用 defineProperty(..) 方法来修改属性描述符,修改为false之后再进行配置就无法配置了,即便属性是 configurable:false，我们还是可以
   把 writable 的状态由 true 改为 false，但是无法由 false 改为 true。除了修改之外，而且无法删除这个属性
3. Enumerable
   从名字就可以看出，这个描述符控制的是属性是否会出现在对象的属性枚举中，比如说
   for..in 循环。如果把 enumerable 设置成 false，这个属性就不会出现在枚举中，虽然仍
   然可以正常访问它。相对地，设置成 true 就会让它出现在枚举中。

### 不变性

- 如果给一个对象设置不变性，并且属性是引用类型的话，那么他的值还是可以发生变化
- 设置方法（针对普通类型）

```javascript
    var myObject = {};
    Object.defineProperty( myObject, "FAVORITE_NUMBER", {
    value: 42,
    writable: false,
    configurable: false
    } );
```

### 禁止扩展

- 如果你想禁止一个对象添加新属性并且保留已有属性，可以使用Object.preventExtensions(..)

```javascript
    var myObject = {
    a:2
    };
    Object.preventExtensions( myObject );
    myObject.b = 3;
    myObject.b; // undefined
```

### 密封

- Object.seal(..) 会创建一个“密封”的对象，这个方法实际上会在一个现有对象上调用Object.preventExtensions(..) 并把所有现有属性标记为 configurable:false。所以，密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性（虽然可以修改属性的值）。

### 冻结

- Object.freeze(..) 会创建一个冻结对象，这个方法实际上会在一个现有对象上调用Object.seal(..) 并把所有“数据访问”属性标记为 writable:false，这样就无法修改它们的值。

### [[GET]]

- 获取对象的属性的时候都会执行这个方法，这个方法会在当前对象和原型链上查找这个属性，当这个属性找到了就会返回，如果没找到就会返回undefind，和普通变量的报错是不同的

### [[PUT]]

- 主要作用是给对象添加属性的
- PUT 主要执行过程是
  - 属性是否是访问描述符，如果是并且存在setter就调用
  - 属性的数据描述符中的writable 是否是 false ，是的话就失败，严格模式下报错
  - 如果都不是就将这个值设置为属性的值

### GETTER 和 SETTER

- 在 ES5 中可以使用 getter 和 setter 部分改写默认操作，但是只能应用在单个属性上，无法应用在整个对象上。getter 是一个隐藏函数，会在获取属性值时调用。setter 也是一个隐藏函数，会在设置属性值时调用。

使用
```javascript
    var myObject = {
    // 给 a 定义一个 getter
        get a() {
          return 2;
        }
    };
    Object.defineProperty(myObject, "b", { // 描述符
            // 给 b 设置一个 getter
            get: function(){ return this.a * 2 },
            // 确保 b 会出现在对象的属性列表中
            enumerable: true
        }
    );
    myObject.a; // 2
    myObject.b; // 4
    var myObject = {
        // 给 a 定义一个 getter
        get a() {
            return this._a_;
        },
        // 给 a 定义一个 setter
        set a(val) {
            this._a_ = val * 2;
        }
    };
    myObject.a = 2;
    myObject.a; // 4
```
- 使用中间变量（如 _a_）是为了：

1. 避免无限递归：直接访问同名属性会触发 getter/setter

2. 分离存储和逻辑：内部变量负责存储，getter/setter 负责业务逻辑

3. 保持接口一致性：外部使用简单的 obj.a，内部可以有复杂逻辑

避免临时变量可以使用闭包，类似vue

[超级简化版vue响应式原理同时避免创建临时变量](../demos/05-简化版vue.html)]

### 存在性

使用下面的变量来查看对象是否存在相应的属性

```javascript
("a" in myObject); // true
("b" in myObject); // false
myObject.hasOwnProperty( "a" ); // true
myObject.hasOwnProperty( "b" ); // false
```

### 遍历

- for 最普通的遍历
- for in 只能遍历键值
```javascript
for (var k in myObject) {
console.log( k, myObject[k] );
}
```
- for of 遍历的是对象的属性
```javascript
for (var v of myArray) {
console.log( v );
}
```
// TODO 136

