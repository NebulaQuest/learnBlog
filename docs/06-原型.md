## 原型

- 对于默认的 [[Get]] 操作来说，如果无法在对象本身找到需要的属性，就会继续访问对象的 [[Prototype]] 链，所有普通的 [[Prototype]] 链最终都会指向内置的 Object.prototype

```javascript
    var anotherObject = {
      a:2
    };
    // 创建一个关联到 anotherObject 的对象
    var myObject = Object.create( anotherObject );
    myObject.a; // 2
```

- 如果一个属性既在当前对象中，又在原型中，那么就会发生**屏蔽**，包含的属性会屏蔽原型链上层的所有对应属性

1. 如果在 [[Prototype]] 链上层存在名为 foo 的普通数据访问属性并且没有被标记为只读（writable:false），那就会直接在 myObject 中添加一个名为 foo 的新 属性，它是屏蔽属性。
2. 如果在 [[Prototype]] 链上层存在 foo，但是它被标记为只读（writable:false），那么无法修改已有属性或者在 myObject 上创建屏蔽属性。如果运行在严格模式下，代码会抛出一个错误。否则，这条赋值语句会被忽略。总之，不会发生屏蔽。
3. 如果在 [[Prototype]] 链上层存在 foo 并且它是一个 setter，那就一定会调用这个 setter。foo 不会被添加到（或者说屏蔽于）myObject，也不会重新定义 foo 这个 setter

```javascript
    const obj = Object.create(null);
    obj.foo = 123;            // 自己会创建 foo
    
    // 但如果有 setter：
    const base = {
        set foo(v) { console.log('setter called'); }
    };
    const obj2 = Object.create(base);
    obj2.foo = 123;           // 调用 setter，不创建新属性
```

上面2中只存在于=的情况，如果使用Object.defineProperty(...) 中还是可以赋值的

- JavaScript 的对象系统不是基于“复制”机制，而是基于“关联（引用）机制”
- 在 Java/C++ 中，当你 new 一个对象时，对象会拥有自己一份方法；但在 JavaScript 中，实例并 不会拥有方法的拷贝，只会“引用”原型上的方法。

```javascript
function NothingSpecial() {
    console.log( "Don't mind me!" );
}
var a = new NothingSpecial();
// "Don't mind me!"
a; // {}
```
- 这段代码中，并不是 Java/C++ 中的new 一个对象，他只是创建了一个空对象，并和NothingSpecial.prototype 产生了关联
- NothingSpecial 只是一个普通的函数，但是使用 new 调用时，它就会构造一个对象并赋值 给 a，这看起来像是 new 的一个副作用（无论如何都会构造一个对象）。这个调用是一个构造函数调用，但是 NothingSpecial 本身并不是一个构造函数。

```javascript
function Foo(name) {
    this.name = name;
}
Foo.prototype.myName = function() {
    return this.name;
};
var a = new Foo( "a" );
var b = new Foo( "b" );
a.myName(); // "a"
b.myName(); // "b"

```
New 的过程
1. 创建一个全新的空对象  → {}
2. 让这个对象的 [[Prototype]] 指向 Foo.prototype (定义的myName方法就有了)
3. 绑定 this 到这个新对象（关键！！！）（这一步是因为构造函数的this指向创建的对象，这里是构造函数调用）
4. 执行 Foo 函数体（this.name = name）
5. 将这个对象返回

- 那么构造函数调用和普通函数调用有什么区别

| 特性      | 普通函数调用                | 构造函数调用      |
|---------|-----------------------|-------------|
| 调用方式    | 直接调用                  | 	使用 new 关键字 |
| this 指向 | 	全局对象/undefined       | 	新创建的对象实例   |
| 返回值     | 	return 的值或 undefined | 新对象实例（默认）   |
| 主要用途    | 执行操作，返回结果             | 创建和初始化对象    |

- 构造函数：

默认返回新创建的对象实例

如果显式返回对象，则返回该对象

如果显式返回原始值，则忽略并仍然返回新对象

- JavaScript中会根据语法进行判断当前的函数是被当做构造函数使用还是被当做普通函数调用

```javascript
function Foo() { /* .. */ }
Foo.prototype = { /* .. */ }; // 创建一个新原型对象
var a1 = new Foo();
a1.constructor === Foo; // false!
a1.constructor === Object; // true!
```
构造函数也是在Foo.prototype中的，同时构造函数是不可枚举，但是可以自行修改的

### Object.create()

Object.create(..) 会凭空创建一个“新”对象并把新对象内部的 [[Prototype]] 关联到你
指定的对象（本例中是 Foo.prototype）。

### 修改一个对象的prototype

#### Object.setPrototypeOf( Bar.prototype, Foo.prototype );

### 检查“类”关系

检查一个实例（JavaScript 中的对象）的继承祖先（JavaScript 中的委托关联）通常被称为
内省（或者反射）。

#### instanceof

- instanceof 操作符的左操作数是一个普通的对象，右操作数是一个函数。instanceof 回答
的问题是：在 a 的整条 [[Prototype]] 链中是否有指向 Foo.prototype 的对象？
- 这种方法只能检查一个属性是否指向一个对象，判断一个对象是否指向一个对象的时候就看不到了

#### Object.getPrototypeOf( a ) === Foo.prototype;

### __proto__

- 调用这个方法可以实现对象的向上查找，查找原型链上的内容,同时可以查看被屏蔽前的数据

### 行为委托

- 行为委托和类的继承有本质的区别，委托是将公共方法放到更加顶层的对象中，底层对象实现特殊的方法
- 委托行为意味着某些对象在找不到属性或者方法引用时会把这个请求委托给另一
  个对象。
- 你无法在两个或两个以上互相（双向）委托的对象之间创建循环委托。如果你把 B 关联到
  A 然后试着把 A 关联到 B，就会出错。如果调用一个AB都不存在的属性或者方法的时候就会发生无限循环

