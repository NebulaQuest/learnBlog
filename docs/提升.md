## 提升

### var a = 2

- 这个操作是分为两步的
  - 第一步是声明 var a, 这一步是在编译阶段就执行了，编译过程
  - 第二部是赋值 a = 2, 这一步是在代码执行的阶段执行的，引擎执行代码的过程

```javascript
    console.log(a) // 输出为undefind
    var a = 2;
    // 下面为实际的执行过程
    var a
    console.log(a) // 执行到这的时候a变量已经被声明，但是a变量没有执行赋值操作。所以没有赋值的变量在直接引用的时候都会输出undefind
    a = 2
```

- 因此被定义的变量和函数，定义的过程会被“移动”到代码最上面，这就叫提升
- 只有变量的定义会被提升，其他的代码只会保留在原地
- 函数的提升要比变量的提升优先级要高

## 作用域闭包

- 闭包的概念：当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时
  就产生了闭包。
- 闭包不一定是回调函数，但是回调函数一定是闭包
- 延迟被销毁，因为函数内部的闭包，一直调用函数内部的变量，所以，变量一直处于被引用的状态，所以不会被垃圾回收机制回收
- 同时闭包是实现js模块化的重要组成部分，他让函数内部的**私有变量**可以被访问，类似java的形式，在函数内部可以声明对外部的接口，同时还保证了函数内部的变量不被污染

### 循环与闭包

- 查看下面这段代码
```javascript
    for (var i = 0; i < 10; i++) {
      setTimeout(()=>{
	      console.log(i) // 结果输出了10个10		
      },0)  
    }
```
- 这是因为当执行的过程中，setTime一直访问的是公共区域的变量i，并没有形成自己的变量
- 但是setTimeOut是 微任务，他会在正常的代码执行之后再执行，所以for循环完成后才会执行setTimeOut的函数，从而输出10个10
- 想要解决这种方法的根本是给setTimeOut创建一个数组自己作用域的变量，让其内容不能被其他作用域的内容所污染


```javascript
    function bar() {
      var a = 2;
      (function foo() {
	      console.log(a) // 输出a
      })()
    }
    bar()
    // 或者将 foo返回让内部的函数可以任意位置被调用，同时可以返回bar内部的变量
```
#### [更多示例](../demos/first.html)